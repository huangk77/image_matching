使用OpenCV C++进行实现，可以使用OpenCV-contribe内的库，OpenCV的版本最好为4.10.0

变量类型定义：
1，矩阵类别CV_32F，通道数可选。
2，目前已实现的函数 fft2d ifft2d circshift(fftshift, ifftshift) ，矩阵整体atan2，meshgrid
3，遇到cell的情况，可以用std::vector<cv::Mat> mat_vec容器保存，在这里，mat_vec是一个vector，vector的每一个元素都是一个cv::Mat，可以往里面存入矩阵，存入方法为  .push_back(images.clone()) ，请注意一定要clone创建一个新的备份，不然外面修改了images之后，容器里面的矩阵也会被修改。
4， 函数输入的时候最好都使用CV_Assert限定输入矩阵的属性，以防未知的错误。例如  CV_Assert(src.channels() == 1);  就是保证矩阵src的通道数为1，如果输入矩阵不满足要求，此处会报错终止。
5， 如果使用Visual Studio开发，可以看到OpenCV Mat的每一个元素的值，但是如果使用Vscode的话，据我所知是无法知道的，这时可以使用std::cout << mat << std::endl，输出矩阵，对比c++矩阵的值和Matlab的输出是否一致。但是不要输出太大的矩阵，附件里面有一张16*16的bird_resize.png格式的照片，可以用作测试图片，逐步debug和Matlab输出的异同，因为精度的关系，可能会有一点误差，过小的误差就可以忽略不计了。
6， 如果输入不是矩阵，可以自定义一个Mat输入， 维度可改，Matlab也可以设置为同一个输入，测试矩阵维度一般在20*20以内验证即可，方式为：

const cv::Mat test_input_mat = (cv::Mat_<float>(5, 5) << 0.016531580643701, 0.029701870689091, 0.036108291846035, 0.029701870689091, 0.016531580643701,
                              0.029701870689091, 0.053364596008407, 0.064874850041854, 0.053364596008407, 0.029701870689091,
                              0.036108291846035, 0.064874850041854, 0.078867760327278, 0.064874850041854, 0.036108291846035,
                              0.029701870689091, 0.053364596008407, 0.0648748500418541, 0.0533645960084072, 0.0297018706890914,
                              0.0165315806437010, 0.0297018706890914, 0.0361082918460354, 0.0297018706890914, 0.0165315806437010);
